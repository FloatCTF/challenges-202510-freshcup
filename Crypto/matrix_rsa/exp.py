import gmpy2
from sage.all import *
from Crypto.Util.number import *

e = 65537
p = 11059777674910619082262290082674004930480990546814925226009352049989000619312329995394894864637578777377325955884178905867874543274411594326761559435367927
B = [[10514877604615595550407234901468645229247425046036172545484396072733310183564420560586543087440316849695497134879072860599900018528810854614988023855375722, 10104213550928234722507377968037195353153901639423579214389554199196701569816209723808800388761520382465669321020545973253468249789422328577794603915873575],
     [1664451695732112316906862267092207891151390415505569297553253782029170790107992046556425229582023305010505403290304252068026406543689285609089400646405413, 4991047586726804496050285713610180625656745159706895800487794414303100551739695316185064665422519044836570939808518744503010830965277267315468770960054347]]

# 将B转换为Zmod(p)上的矩阵
B = Matrix(Zmod(p), B)

# 计算矩阵群GL(2, Z_p)的阶
# 对于2x2矩阵，阶为 (p^2 - 1)(p^2 - p)
phi = (p ** 2 - 1) * (p ** 2 - p)

# 计算解密指数 d = e^(-1) mod phi
d = gmpy2.invert(e, phi)

# 解密：M = B^d mod p
M = B ** d % p

# 尝试从矩阵的每个元素中提取可能的flag
print("[*] 解密后的矩阵元素：")
for i in range(2):
    for j in range(2):
        element = int(M[i, j])
        decoded = long_to_bytes(element)
        print(f"M[{i}][{j}] = {element}")

        # 检查是否包含flag格式
        if b'floatctf{' in decoded:
            print(f"\n[+] 找到flag在M[{i}][{j}]:")
            print(f"    {decoded}")
